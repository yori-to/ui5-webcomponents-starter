import library from '../library.js';
import EventProvider from '../../base/EventProvider.js';
import HashChanger from './HashChanger.js';
import Route from './Route.js';
import Views from './Views.js';
import Targets from './Targets.js';
import History from './History.js';
import crossroads from '../../thirdparty/crossroads.js';
import UriParameters from '../../../base/util/UriParameters.js';
import deepEqual from '../../../base/util/deepEqual.js';
import Log from '../../../base/Log.js';
import jQuery from '../../thirdparty/jquery.js';
var oRouters = {};
var Router = EventProvider.extend('sap.ui.core.routing.Router', {
    constructor: function (oRoutes, oConfig, oOwner, oTargetsConfig, oRouterHashChanger) {
        EventProvider.apply(this);
        this._oConfig = oConfig || {};
        this._oRouter = crossroads.create();
        this._oRouter.ignoreState = true;
        this._oRoutes = {};
        this._oOwner = oOwner;
        function checkUrl() {
            if (new UriParameters(window.location.href).get('sap-ui-xx-asyncRouting') === 'true') {
                Log.warning('Activation of async view loading in routing via url parameter is only temporarily supported and may be removed soon', 'Router');
                return true;
            }
            return false;
        }
        this._oConfig._async = this._oConfig.async;
        if (this._oConfig._async === undefined) {
            this._oConfig._async = checkUrl();
        }
        this._oViews = new Views({
            component: oOwner,
            async: this._oConfig._async
        });
        if (oTargetsConfig) {
            this._oTargets = this._createTargets(this._oConfig, oTargetsConfig);
        }
        var that = this, aRoutes;
        if (!oRoutes) {
            oRoutes = {};
        }
        if (Array.isArray(oRoutes)) {
            aRoutes = oRoutes;
            oRoutes = {};
            aRoutes.forEach(function (oRouteConfig) {
                oRoutes[oRouteConfig.name] = oRouteConfig;
            });
        }
        jQuery.each(oRoutes, function (sRouteName, oRouteConfig) {
            if (oRouteConfig.name === undefined) {
                oRouteConfig.name = sRouteName;
            }
            that.addRoute(oRouteConfig);
        });
        this._oRouter.bypassed.add(jQuery.proxy(this._onBypassed, this));
        if (oRouterHashChanger) {
            this.setHashChanger(oRouterHashChanger);
        }
    },
    addRoute: function (oConfig, oParent) {
        if (!oConfig.name) {
            Log.error('A name has to be specified for every route', this);
        }
        if (this._oRoutes[oConfig.name]) {
            Log.error('Route with name ' + oConfig.name + ' already exists', this);
        }
        this._oRoutes[oConfig.name] = this._createRoute(this, oConfig, oParent);
    },
    parse: function (sNewHash) {
        if (this._oRouter) {
            this._oRouter.parse(sNewHash);
        } else {
            Log.warning('This router has been destroyed while the hash changed. No routing events where fired by the destroyed instance.', this);
        }
    },
    initialize: function (bIgnoreInitialHash) {
        var that = this;
        if (!this.oHashChanger) {
            this.oHashChanger = HashChanger.getInstance().createRouterHashChanger();
        }
        if (this._bIsInitialized) {
            Log.warning('Router is already initialized.', this);
            return this;
        }
        this._bIsInitialized = true;
        this._bLastHashReplaced = false;
        this._bHashChangedAfterTitleChange = false;
        this.fnHashChanged = function (oEvent) {
            that.parse(oEvent.getParameter('newHash'));
            that._bHashChangedAfterTitleChange = true;
        };
        if (!this.oHashChanger) {
            Log.error('navTo of the router is called before the router is initialized. If you want to replace the current hash before you initialize the router you may use getUrl and use replaceHash of the Hashchanger.', this);
            return this;
        }
        if (this._oTargets) {
            var oHomeRoute = this._oRoutes[this._oConfig.homeRoute];
            this._oTargets.attachTitleChanged(function (oEvent) {
                var oEventParameters = oEvent.getParameters();
                if (oHomeRoute && isHomeRouteTarget(oEventParameters.name, oHomeRoute._oConfig.name)) {
                    oEventParameters.isHome = true;
                }
                this.fireTitleChanged(oEventParameters);
            }, this);
            this._aHistory = [];
            var oHomeRouteEntry = oHomeRoute && getHomeEntry(this._oOwner, oHomeRoute);
            if (oHomeRouteEntry) {
                this._aHistory.push(oHomeRouteEntry);
            }
        }
        this.oHashChanger.init();
        this.oHashChanger.attachEvent('hashChanged', this.fnHashChanged);
        if (!bIgnoreInitialHash) {
            this.parse(this.oHashChanger.getHash());
        }
        return this;
    },
    stop: function () {
        if (!this._bIsInitialized) {
            Log.warning('Router is not initialized. But it got stopped', this);
        }
        if (this.fnHashChanged) {
            this.oHashChanger.detachEvent('hashChanged', this.fnHashChanged);
        }
        if (this.fnHashReplaced) {
            this.oHashChanger.detachEvent('hashReplaced', this.fnHashReplaced);
        }
        if (this._matchedRoute) {
            this._matchedRoute.fireEvent('switched');
            this._matchedRoute = null;
        }
        this._bIsInitialized = false;
        return this;
    },
    isStopped: function () {
        return this._bIsInitialized === false;
    },
    isInitialized: function () {
        return this._bIsInitialized === true;
    },
    getHashChanger: function () {
        return this.oHashChanger;
    },
    setHashChanger: function (oHashChanger) {
        if (this.oHashChanger) {
            Log.warning('The Router already has a HashChanger set and this call is ignored');
        } else {
            this.oHashChanger = oHashChanger;
        }
        return this;
    },
    destroy: function () {
        if (this.bIsDestroyed) {
            return this;
        }
        EventProvider.prototype.destroy.apply(this);
        if (this._oViews) {
            this._oViews.destroy();
            this._oViews = null;
        }
        if (!this._bIsInitialized) {
            Log.info('Router is not initialized, but got destroyed.', this);
        }
        if (this.fnHashChanged) {
            this.oHashChanger.detachEvent('hashChanged', this.fnHashChanged);
        }
        if (this.fnHashReplaced) {
            this.oHashChanger.detachEvent('hashReplaced', this.fnHashReplaced);
        }
        this._oRouter.removeAllRoutes();
        this._oRouter = null;
        jQuery.each(this._oRoutes, function (iRouteIndex, oRoute) {
            oRoute.destroy();
        });
        this._oRoutes = null;
        this._oConfig = null;
        if (this._oTargets) {
            this._oTargets.destroy();
            this._oTargets = null;
        }
        delete this._bIsInitialized;
        this.bIsDestroyed = true;
        return this;
    },
    getURL: function (sName, oParameters) {
        if (oParameters === undefined) {
            oParameters = {};
        }
        var oRoute = this.getRoute(sName);
        if (!oRoute) {
            Log.warning('Route with name ' + sName + ' does not exist', this);
            return;
        }
        return oRoute.getURL(oParameters);
    },
    match: function (sHash) {
        return Object.keys(this._oRoutes).some(function (sRouteName) {
            return this._oRoutes[sRouteName].match(sHash);
        }.bind(this));
    },
    getRoute: function (sName) {
        return this._oRoutes[sName];
    },
    getViews: function () {
        return this._oViews;
    },
    _createTargets: function (oConfig, oTargetsConfig) {
        return new Targets({
            views: this._oViews,
            config: oConfig,
            targets: oTargetsConfig
        });
    },
    _createRoute: function (oRouter, oConfig, oParent) {
        return new Route(oRouter, oConfig, oParent);
    },
    getView: function (sViewName, sViewType, sViewId) {
        Log.warning('Deprecated API Router#getView called - use Router#getViews instead.', this);
        var oView = this._oViews._getViewWithGlobalId({
            viewName: sViewName,
            type: sViewType,
            id: sViewId
        });
        this.fireViewCreated({
            view: oView,
            viewName: sViewName,
            type: sViewType
        });
        return oView;
    },
    setView: function (sViewName, oView) {
        this._oViews.setView(sViewName, oView);
        return this;
    },
    navTo: function (sName, oParameters, bReplace) {
        var sURL = this.getURL(sName, oParameters);
        if (sURL === undefined) {
            Log.error('Can not navigate to route with name ' + sName + ' because the route does not exist');
        }
        if (bReplace) {
            this._bLastHashReplaced = true;
            this.oHashChanger.replaceHash(sURL);
        } else {
            this.oHashChanger.setHash(sURL);
        }
        return this;
    },
    getTargets: function () {
        return this._oTargets;
    },
    getTarget: function (vName) {
        return this._oTargets.getTarget(vName);
    },
    attachRouteMatched: function (oData, fnFunction, oListener) {
        this.attachEvent('routeMatched', oData, fnFunction, oListener);
        return this;
    },
    detachRouteMatched: function (fnFunction, oListener) {
        this.detachEvent('routeMatched', fnFunction, oListener);
        return this;
    },
    fireRouteMatched: function (mArguments) {
        this.fireEvent('routeMatched', mArguments);
        if (Router._trackRouteMatched) {
            Router._trackRouteMatched(this._oConfig.controlId, this, mArguments);
        }
        return this;
    },
    attachBeforeRouteMatched: function (oData, fnFunction, oListener) {
        this.attachEvent('beforeRouteMatched', oData, fnFunction, oListener);
        return this;
    },
    detachBeforeRouteMatched: function (fnFunction, oListener) {
        this.detachEvent('beforeRouteMatched', fnFunction, oListener);
        return this;
    },
    fireBeforeRouteMatched: function (mArguments) {
        this.fireEvent('beforeRouteMatched', mArguments);
        return this;
    },
    attachViewCreated: function (oData, fnFunction, oListener) {
        this.attachEvent('viewCreated', oData, fnFunction, oListener);
        return this;
    },
    detachViewCreated: function (fnFunction, oListener) {
        this.detachEvent('viewCreated', fnFunction, oListener);
        return this;
    },
    fireViewCreated: function (mArguments) {
        this.fireEvent('viewCreated', mArguments);
        return this;
    },
    attachRoutePatternMatched: function (oData, fnFunction, oListener) {
        this.attachEvent('routePatternMatched', oData, fnFunction, oListener);
        return this;
    },
    detachRoutePatternMatched: function (fnFunction, oListener) {
        this.detachEvent('routePatternMatched', fnFunction, oListener);
        return this;
    },
    fireRoutePatternMatched: function (mArguments) {
        this.fireEvent('routePatternMatched', mArguments);
        return this;
    },
    attachBypassed: function (oData, fnFunction, oListener) {
        return this.attachEvent(Router.M_EVENTS.BYPASSED, oData, fnFunction, oListener);
    },
    detachBypassed: function (fnFunction, oListener) {
        return this.detachEvent(Router.M_EVENTS.BYPASSED, fnFunction, oListener);
    },
    fireBypassed: function (mArguments) {
        return this.fireEvent(Router.M_EVENTS.BYPASSED, mArguments);
    },
    attachTitleChanged: function (oData, fnFunction, oListener) {
        this.attachEvent(Router.M_EVENTS.TITLE_CHANGED, oData, fnFunction, oListener);
        return this;
    },
    detachTitleChanged: function (fnFunction, oListener) {
        return this.detachEvent(Router.M_EVENTS.TITLE_CHANGED, fnFunction, oListener);
    },
    fireTitleChanged: function (mArguments) {
        var sDirection = History.getInstance().getDirection(), sHash = this.oHashChanger.getHash(), HistoryDirection = library.routing.HistoryDirection, oLastHistoryEntry = this._aHistory[this._aHistory.length - 1], oNewHistoryEntry;
        if (sDirection === HistoryDirection.Backwards && oLastHistoryEntry && !oLastHistoryEntry.isHome) {
            if (oLastHistoryEntry && oLastHistoryEntry.title !== mArguments.title) {
                this._aHistory.pop();
            }
        } else if (oLastHistoryEntry && oLastHistoryEntry.hash == sHash) {
            oLastHistoryEntry.title = mArguments.title;
            this._aHistory.some(function (oEntry, i, aHistory) {
                if (i < aHistory.length - 1 && deepEqual(oEntry, oLastHistoryEntry)) {
                    return aHistory.splice(i, 1);
                }
            });
        } else {
            if (this._bLastHashReplaced) {
                this._aHistory.pop();
            }
            oNewHistoryEntry = {
                hash: sHash,
                title: mArguments.title
            };
            this._aHistory.some(function (oEntry, i, aHistory) {
                if (deepEqual(oEntry, oNewHistoryEntry)) {
                    return aHistory.splice(i, 1);
                }
            });
            this._aHistory.push(oNewHistoryEntry);
        }
        mArguments.history = this._aHistory.slice(0, -1);
        this.fireEvent(Router.M_EVENTS.TITLE_CHANGED, mArguments);
        this._bLastHashReplaced = false;
        return this;
    },
    getTitleHistory: function () {
        return this._aHistory || [];
    },
    register: function (sName) {
        oRouters[sName] = this;
        return this;
    },
    _onBypassed: function (sHash) {
        var fnFireEvent = function () {
            this.fireBypassed({ hash: sHash });
        }.bind(this);
        if (this._oConfig.bypassed) {
            var oReturn = this._oTargets.display(this._oConfig.bypassed.target, { hash: sHash });
            if (oReturn instanceof Promise) {
                oReturn.then(fnFireEvent);
                return;
            }
        }
        fnFireEvent();
    },
    _isAsync: function () {
        return this._oConfig._async;
    },
    metadata: {
        publicMethods: [
            'initialize',
            'getURL',
            'register',
            'getRoute'
        ]
    }
});
function isHomeRouteTarget(sRouteTarget, sHomeRoute) {
    return sHomeRoute && sHomeRoute.indexOf(sRouteTarget) > -1;
}
function getHomeEntry(oOwnerComponent, oHomeRoute) {
    var sHomeRoutePattern = oHomeRoute.getPattern(), sAppTitle = oOwnerComponent && oOwnerComponent.getManifestEntry('sap.app/title');
    if (sHomeRoutePattern === '' || sHomeRoutePattern !== undefined && !/({.*})+/.test(sHomeRoutePattern)) {
        return {
            hash: sHomeRoutePattern,
            isHome: true,
            title: sAppTitle
        };
    } else {
        Log.error('Routes with dynamic parts cannot be resolved as home route.');
    }
}
Router.M_EVENTS = {
    BEFORE_ROUTE_MATCHED: 'beforeRouteMatched',
    ROUTE_MATCHED: 'routeMatched',
    ROUTE_PATTERN_MATCHED: 'routePatternMatched',
    VIEW_CREATED: 'viewCreated',
    BYPASSED: 'bypassed',
    TITLE_CHANGED: 'titleChanged'
};
Router._trackRouteMatched = undefined;
Router.getRouter = function (sName) {
    return oRouters[sName];
};
export default Router;