import HashChangerBase from './HashChangerBase.js';
import Log from '../../../base/Log.js';
var RouterHashChanger = HashChangerBase.extend('sap.ui.core.routing.RouterHashChanger', {
    constructor: function (mSettings) {
        if (!mSettings || !mSettings.parent) {
            throw new Error('sap.ui.core.routing.RouterHashChanger can\'t be instantiated without a parent');
        }
        this.parent = mSettings.parent;
        this.hash = mSettings.hash || '';
        this.subHashMap = mSettings.subHashMap;
        this.key = mSettings.key || '';
        HashChangerBase.apply(this);
    }
});
RouterHashChanger.prototype.init = function () {
    this.parent.init();
};
RouterHashChanger.prototype._generatePrefixedKey = function (sKey) {
    return this.key ? this.key + '-' + sKey : sKey;
};
RouterHashChanger.prototype.createSubHashChanger = function (sKey) {
    this.children = this.children || {};
    var sPrefixedKey = this._generatePrefixedKey(sKey);
    if (this.children[sPrefixedKey]) {
        return this.children[sPrefixedKey];
    }
    var oChild = new RouterHashChanger({
        key: sPrefixedKey,
        parent: this,
        subHashMap: this.subHashMap,
        hash: this.subHashMap && this.subHashMap[sPrefixedKey] || ''
    });
    oChild.attachEvent('hashSet', this._onChildHashChanged.bind(this, sPrefixedKey));
    oChild.attachEvent('hashReplaced', this._onChildHashChanged.bind(this, sPrefixedKey));
    this.children[sPrefixedKey] = oChild;
    return oChild;
};
RouterHashChanger.prototype.fireHashChanged = function (sHash, oSubHashMap, bUpdateHashOnly) {
    var aKeys, sOldHash = this.hash;
    this.hash = sHash;
    this.subHashMap = oSubHashMap;
    if (!bUpdateHashOnly) {
        this.fireEvent('hashChanged', {
            newHash: sHash,
            oldHash: sOldHash
        });
    }
    if (this.children) {
        aKeys = Object.keys(this.children);
        aKeys.forEach(function (sChildKey) {
            var sChildHash = oSubHashMap[sChildKey] === undefined ? '' : oSubHashMap[sChildKey];
            this.children[sChildKey].fireHashChanged(sChildHash, oSubHashMap, bUpdateHashOnly);
        }.bind(this));
    }
};
RouterHashChanger.prototype._onChildHashChanged = function (sKey, oEvent) {
    var sChildKey = oEvent.getParameter('key') || sKey;
    this.fireEvent(oEvent.getId(), {
        hash: oEvent.getParameter('hash'),
        key: sChildKey,
        deletePrefix: oEvent.getParameter('deletePrefix')
    });
};
RouterHashChanger.prototype._hasRouterAttached = function () {
    return this.hasListeners('hashChanged');
};
RouterHashChanger.prototype._collectActiveDescendantPrefix = function () {
    if (this.children) {
        var aKeys = Object.keys(this.children);
        return aKeys.reduce(function (aPrefix, sKey) {
            var oChild = this.children[sKey];
            if (oChild._hasRouterAttached()) {
                aPrefix.push(sKey);
                Array.prototype.push.apply(aPrefix, oChild._collectActiveDescendantPrefix());
            }
            return aPrefix;
        }.bind(this), []);
    } else {
        return [];
    }
};
RouterHashChanger.prototype.getHash = function () {
    return this.hash;
};
RouterHashChanger.prototype.setHash = function (sHash) {
    if (this._hasRouterAttached()) {
        var aDeletePrefix = this._collectActiveDescendantPrefix();
        this.fireEvent('hashSet', {
            hash: sHash,
            deletePrefix: aDeletePrefix
        });
    } else {
        Log.warning('The function setHash is called on a router which isn\'t matched within the last browser hashChange event. The call is ignored.');
    }
};
RouterHashChanger.prototype.replaceHash = function (sHash) {
    if (this._hasRouterAttached()) {
        var aDeletePrefix = this._collectActiveDescendantPrefix();
        this.fireEvent('hashReplaced', {
            hash: sHash,
            deletePrefix: aDeletePrefix
        });
    } else {
        Log.warning('The function replaceHash is called on a router which isn\'t matched within the last browser hashChange event. The call is ignored.');
    }
};
RouterHashChanger.prototype.destroy = function () {
    this.parent.deregisterRouterHashChanger(this);
    if (this.children) {
        Object.keys(this.children).forEach(function (sKey) {
            var oChild = this.children[sKey];
            oChild.destroy();
        }.bind(this));
        delete this.children;
    }
    delete this.hash;
    delete this.subHashMap;
    delete this.parent;
    delete this.key;
    HashChangerBase.prototype.destroy.apply(this, arguments);
};
RouterHashChanger.prototype.deregisterRouterHashChanger = function (oRouterHashChanger) {
    if (this.children) {
        Object.keys(this.children).some(function (sKey) {
            var oChild = this.children[sKey];
            if (oChild === oRouterHashChanger) {
                delete this.children[sKey];
                return true;
            }
        }.bind(this));
    }
};
export default RouterHashChanger;