import WebSocket from './WebSocket.js';
import Log from '../../../base/Log.js';
var SapPcpWebSocket = WebSocket.extend('sap.ui.core.ws.SapPcpWebSocket', {
    constructor: function (sUrl, aProtocols) {
        WebSocket.apply(this, arguments);
    }
});
SapPcpWebSocket.SUPPORTED_PROTOCOLS = { v10: 'v10.pcp.sap.com' };
SapPcpWebSocket._deserializeRegexp = /((?:[^:\\]|(?:\\.))+):((?:[^:\\\n]|(?:\\.))*)/;
SapPcpWebSocket._SEPARATOR = '\n\n';
SapPcpWebSocket._MESSAGE = 'MESSAGE';
SapPcpWebSocket.prototype._onopen = function () {
    var bSuccess = false;
    if (this.getProtocol() === '') {
        bSuccess = true;
    } else {
        for (var protocol in SapPcpWebSocket.SUPPORTED_PROTOCOLS) {
            if (SapPcpWebSocket.SUPPORTED_PROTOCOLS.hasOwnProperty(protocol)) {
                if (SapPcpWebSocket.SUPPORTED_PROTOCOLS[protocol] === this.getProtocol()) {
                    bSuccess = true;
                    break;
                }
            }
        }
    }
    if (bSuccess) {
        this.fireOpen();
    } else {
        Log.error('Unsupported protocol \'' + this.getProtocol() + '\' selected by the server. ' + 'Connection will be closed.');
        this.close('Unsupported protocol selected by the server');
    }
};
SapPcpWebSocket.prototype._onmessage = function (oMessageEvent) {
    var iSplitPos = -1, oEventData = {};
    if (typeof oMessageEvent.data === 'string') {
        iSplitPos = oMessageEvent.data.indexOf(SapPcpWebSocket._SEPARATOR);
    }
    if (iSplitPos !== -1) {
        oEventData.pcpFields = this._extractPcpFields(oMessageEvent.data.substring(0, iSplitPos));
        oEventData.data = oMessageEvent.data.substr(iSplitPos + SapPcpWebSocket._SEPARATOR.length);
    } else {
        Log.warning('Invalid PCP message received: ' + oMessageEvent.data);
        oEventData.pcpFields = {};
        oEventData.data = oMessageEvent.data;
    }
    this.fireMessage(oEventData);
};
SapPcpWebSocket.prototype._extractPcpFields = function (sHeader) {
    var aFields = sHeader.split('\n'), aLine = [], oPcpFields = {};
    for (var i = 0; i < aFields.length; i++) {
        aLine = aFields[i].match(SapPcpWebSocket._deserializeRegexp);
        if (aLine && aLine.length === 3) {
            oPcpFields[this._unescape(aLine[1])] = this._unescape(aLine[2]);
        }
    }
    return oPcpFields;
};
SapPcpWebSocket.prototype._unescape = function (sEscaped) {
    var aParts = sEscaped.split('\b'), sUnescaped = '';
    for (var i = 0; i < aParts.length; i++) {
        aParts[i] = aParts[i].replace(/\\\\/g, '\b').replace(/\\:/g, ':').replace(/\\n/g, '\n').replace(/\u0008/g, '\\');
    }
    sUnescaped = aParts.join('\b');
    return sUnescaped;
};
SapPcpWebSocket.prototype._serializePcpFields = function (oPcpFields, sMessageType, sPcpAction) {
    var oSerialized = '', sFieldName = '', sPcpBodyType = '';
    if (sMessageType === 'string') {
        sPcpBodyType = 'text';
    } else if (sMessageType === 'blob' || sMessageType === 'arraybuffer') {
        sPcpBodyType = 'binary';
    }
    if (oPcpFields && typeof oPcpFields === 'object') {
        for (sFieldName in oPcpFields) {
            if (oPcpFields.hasOwnProperty(sFieldName) && sFieldName.indexOf('pcp-') !== 0) {
                oSerialized += this._escape(sFieldName) + ':' + this._escape(String(oPcpFields[sFieldName])) + '\n';
            }
        }
    }
    return 'pcp-action:' + sPcpAction + '\npcp-body-type:' + sPcpBodyType + '\n' + oSerialized + '\n';
};
SapPcpWebSocket.prototype._escape = function (sUnEscaped) {
    return sUnEscaped.replace(/\\/g, '\\\\').replace(/:/g, '\\:').replace(/\n/g, '\\n');
};
SapPcpWebSocket.prototype.send = function (message, oPcpFields) {
    var sMessageType = typeof message, sPcpFields = '';
    sPcpFields = this._serializePcpFields(oPcpFields, sMessageType, SapPcpWebSocket._MESSAGE);
    WebSocket.prototype.send.call(this, sPcpFields + message);
    return this;
};
export default SapPcpWebSocket;