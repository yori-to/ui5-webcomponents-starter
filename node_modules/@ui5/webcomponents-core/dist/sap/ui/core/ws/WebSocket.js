import Device from '../../Device.js';
import EventProvider from '../../base/EventProvider.js';
import ReadyState from './ReadyState.js';
import URI from '../../thirdparty/URI.js';
import Log from '../../../base/Log.js';
import jQuery from '../../thirdparty/jquery.js';
var WebSocket = EventProvider.extend('sap.ui.core.ws.WebSocket', {
    constructor: function (sUrl, aProtocols) {
        EventProvider.apply(this);
        if (!Device.support.websocket) {
            throw new Error('Browser does not support WebSockets.');
        }
        if (typeof sUrl !== 'string') {
            throw new Error('sUrl must be a string.');
        }
        if (typeof aProtocols !== 'undefined' && !Array.isArray(aProtocols) && typeof aProtocols !== 'string') {
            throw new Error('aProtocols must be a string, array of strings or undefined.');
        }
        this._openConnection(sUrl, aProtocols);
    },
    metadata: {
        publicMethods: [
            'send',
            'close',
            'getReadyState',
            'getProtocol'
        ]
    }
});
WebSocket.prototype.getInterface = function () {
    return this;
};
WebSocket.M_EVENTS = {
    Open: 'open',
    Close: 'close',
    Error: 'error',
    Message: 'message'
};
WebSocket.prototype.attachOpen = function (oData, fnFunction, oListener) {
    this.attachEvent('open', oData, fnFunction, oListener);
    return this;
};
WebSocket.prototype.detachOpen = function (fnFunction, oListener) {
    this.detachEvent('open', fnFunction, oListener);
    return this;
};
WebSocket.prototype.fireOpen = function (mArguments) {
    this.fireEvent('open', mArguments);
    return this;
};
WebSocket.prototype.attachClose = function (oData, fnFunction, oListener) {
    this.attachEvent('close', oData, fnFunction, oListener);
    return this;
};
WebSocket.prototype.detachClose = function (fnFunction, oListener) {
    this.detachEvent('close', fnFunction, oListener);
    return this;
};
WebSocket.prototype.fireClose = function (mArguments) {
    this.fireEvent('close', mArguments);
    return this;
};
WebSocket.prototype.attachError = function (oData, fnFunction, oListener) {
    this.attachEvent('error', oData, fnFunction, oListener);
    return this;
};
WebSocket.prototype.detachError = function (fnFunction, oListener) {
    this.detachEvent('error', fnFunction, oListener);
    return this;
};
WebSocket.prototype.fireError = function (mArguments) {
    this.fireEvent('error', mArguments);
    return this;
};
WebSocket.prototype.attachMessage = function (oData, fnFunction, oListener) {
    this.attachEvent('message', oData, fnFunction, oListener);
    return this;
};
WebSocket.prototype.detachMessage = function (fnFunction, oListener) {
    this.detachEvent('message', fnFunction, oListener);
    return this;
};
WebSocket.prototype.fireMessage = function (mArguments) {
    this.fireEvent('message', mArguments);
    return this;
};
WebSocket.prototype._resolveFullUrl = function (sUrl) {
    var oUri = new URI(sUrl);
    var oBaseUri = new URI(document.baseURI);
    oBaseUri.search('');
    oBaseUri.protocol(oBaseUri.protocol() === 'https' ? 'wss' : 'ws');
    oUri = oUri.absoluteTo(oBaseUri);
    return oUri.toString();
};
WebSocket.prototype._openConnection = function (sUrl, aProtocols) {
    var sUrl = this._resolveFullUrl(sUrl);
    this._oWs = typeof aProtocols === 'undefined' ? new window.WebSocket(sUrl) : new window.WebSocket(sUrl, aProtocols);
    this._oWs.onopen = jQuery.proxy(this._onopen, this);
    this._oWs.onclose = jQuery.proxy(this._onclose, this);
    this._oWs.onmessage = jQuery.proxy(this._onmessage, this);
    this._oWs.onerror = jQuery.proxy(this._onerror, this);
};
WebSocket.prototype._onopen = function () {
    this.fireOpen();
};
WebSocket.prototype._onclose = function (oCloseEvent) {
    this.fireClose({
        code: oCloseEvent.code,
        reason: oCloseEvent.reason,
        wasClean: oCloseEvent.wasClean
    });
};
WebSocket.prototype._onerror = function (oEvent) {
    this.fireError();
};
WebSocket.prototype._onmessage = function (oMessageEvent) {
    this.fireMessage({ data: oMessageEvent.data });
};
WebSocket.prototype.send = function (sMessage) {
    if (this.getReadyState() === ReadyState.OPEN) {
        this._oWs.send(sMessage);
    } else if (this.getReadyState() === ReadyState.CONNECTING) {
        this.attachEventOnce('open', function (oEvent) {
            this._oWs.send(sMessage);
        });
    } else {
        Log.warning('Unable to send WebSocket message. ' + 'Connection is already closed or closing. message: ' + sMessage);
    }
    return this;
};
WebSocket.prototype.close = function (iCode, sReason) {
    if (typeof iCode === 'string') {
        sReason = iCode;
        iCode = undefined;
    }
    iCode = typeof iCode === 'undefined' ? 1000 : iCode;
    sReason = typeof sReason === 'undefined' ? '' : sReason;
    if (this.getReadyState() === ReadyState.OPEN) {
        this._oWs.close(iCode, sReason);
    } else if (this.getReadyState() === ReadyState.CONNECTING) {
        this.attachEventOnce('open', function (oEvent) {
            this._oWs.close(iCode, sReason);
        });
    } else {
        var sText = '';
        switch (this.getReadyState()) {
        case ReadyState.CLOSED:
            sText = 'Connection is already closed.';
            break;
        case ReadyState.CLOSING:
            sText = 'Connection is already closing.';
            break;
        }
        Log.warning('Unable to close WebSocket connection. ' + sText);
    }
    return this;
};
WebSocket.prototype.getReadyState = function () {
    return this._oWs.readyState;
};
WebSocket.prototype.getProtocol = function () {
    return this._oWs.protocol;
};
export default WebSocket;