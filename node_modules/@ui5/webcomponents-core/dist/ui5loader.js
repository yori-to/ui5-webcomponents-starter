(function (__global) {
  "use strict";
  function pathOnly(href) {
    var p = href.search(/[?#]/);
    return p < 0 ? href : href.slice(0, p);
  }
  function docBase() {
    return pathOnly(document.baseURI);
  }
  var resolveURL = (function (_URL) {
    try {
      if (!(/localhost/).test(new _URL("index.html", "http://localhost:8080/"))) {
        _URL = null;
      }
    } catch (e) {
      _URL = null;
    }
    if (_URL) {
      return function (sURI, sBase) {
        return new _URL(sURI, sBase ? new _URL(sBase, docBase()) : docBase()).toString();
      };
    }
    var doc = document.implementation.createHTMLDocument("Dummy doc for resolveURI");
    var base = doc.createElement("base");
    base.href = docBase();
    doc.head.appendChild(base);
    var anchor = doc.createElement("A");
    doc.body.appendChild(anchor);
    return function (sURI, sBase) {
      base.href = docBase();
      if (sBase != null) {
        anchor.href = sBase;
        base.href = anchor.href;
      }
      anchor.href = sURI;
      return anchor.href;
    };
  })(__global.URL || __global.webkitURL);
  function noop() {}
  function forEach(obj, callback) {
    Object.keys(obj).forEach(function (key) {
      callback(key, obj[key]);
    });
  }
  var log = {
    debug: noop,
    info: noop,
    warning: noop,
    error: noop,
    isLoggable: noop
  };
  var assert = noop;
  var measure;
  var translate;
  var strictModuleDefinitions = true;
  var bGlobalAsyncMode = false;
  var bExposeAsAMDLoader = false;
  var syncCallBehavior = 0;
  var DEFAULT_BASE_URL = "./";
  var vOriginalDefine;
  var vOriginalRequire;
  var mUrlPrefixes = Object.create(null);
  mUrlPrefixes[""] = {
    url: DEFAULT_BASE_URL,
    absoluteUrl: resolveURL(DEFAULT_BASE_URL, document.baseURI)
  };
  var mMaps = Object.create(null), mShims = Object.create(null), mDepCache = Object.create(null), bDebugSources = false, fnIgnorePreload;
  var mModules = Object.create(null), bForceSyncDefines = null, _execStack = [], sLogPrefix = "", iAnonymousModuleCount = 0, MAX_EXEC_SCRIPT_LENGTH = 512 * 1024;
  function urnToUI5(sName) {
    if (!(/\.js$/).test(sName)) {
      return undefined;
    }
    sName = sName.slice(0, -3);
    if ((/^jquery\.sap\./).test(sName)) {
      return sName;
    }
    return sName.replace(/\//g, ".");
  }
  function urnToIDAndType(sResourceName) {
    var basenamePos = sResourceName.lastIndexOf("/"), dotPos = sResourceName.lastIndexOf(".");
    if (dotPos > basenamePos) {
      return {
        id: sResourceName.slice(0, dotPos),
        type: sResourceName.slice(dotPos)
      };
    }
    return {
      id: sResourceName,
      type: ""
    };
  }
  var rJSSubTypes = /(\.controller|\.fragment|\.view|\.designtime|\.support)?.js$/;
  function urnToBaseIDAndSubType(sResourceName) {
    var m = rJSSubTypes.exec(sResourceName);
    if (m) {
      return {
        baseID: sResourceName.slice(0, m.index),
        subType: m[0]
      };
    }
  }
  var rDotSegmentAnywhere = /(?:^|\/)\.+(?=\/|$)/;
  var rDotSegment = /^\.*$/;
  function normalize(sResourceName, sBaseName) {
    var p = sResourceName.search(rDotSegmentAnywhere), aSegments, sSegment, i, j, l;
    if (p < 0) {
      return sResourceName;
    }
    if (p === 0) {
      if (sBaseName == null) {
        throw new Error("relative name not supported ('" + sResourceName + "'");
      }
      sResourceName = sBaseName.slice(0, sBaseName.lastIndexOf("/") + 1) + sResourceName;
    }
    aSegments = sResourceName.split("/");
    for ((i = 0, j = 0, l = aSegments.length); i < l; i++) {
      sSegment = aSegments[i];
      if (rDotSegment.test(sSegment)) {
        if (sSegment === "." || sSegment === "") {
          continue;
        } else if (sSegment === "..") {
          if (j === 0) {
            throw new Error("Can't navigate to parent of root ('" + sResourceName + "')");
          }
          j--;
        } else {
          throw new Error("Illegal path segment '" + sSegment + "' ('" + sResourceName + "')");
        }
      } else {
        aSegments[j++] = sSegment;
      }
    }
    aSegments.length = j;
    return aSegments.join("/");
  }
  function registerResourcePath(sResourceNamePrefix, sUrlPrefix) {
    sResourceNamePrefix = String(sResourceNamePrefix || "");
    if (sUrlPrefix == null) {
      if (sResourceNamePrefix) {
        if (mUrlPrefixes[sResourceNamePrefix]) {
          delete mUrlPrefixes[sResourceNamePrefix];
          log.info("registerResourcePath ('" + sResourceNamePrefix + "') (registration removed)");
        }
        return;
      }
      sUrlPrefix = DEFAULT_BASE_URL;
      log.info("registerResourcePath ('" + sResourceNamePrefix + "') (default registration restored)");
    }
    sUrlPrefix = pathOnly(String(sUrlPrefix));
    if (sUrlPrefix.slice(-1) !== "/") {
      sUrlPrefix += "/";
    }
    mUrlPrefixes[sResourceNamePrefix] = {
      url: sUrlPrefix,
      absoluteUrl: resolveURL(sUrlPrefix)
    };
  }
  function getResourcePath(sResourceName, sSuffix) {
    var sNamePrefix = sResourceName, p = sResourceName.length, sPath;
    while (p > 0 && !mUrlPrefixes[sNamePrefix]) {
      p = sNamePrefix.lastIndexOf("/");
      sNamePrefix = p > 0 ? sNamePrefix.slice(0, p) : "";
    }
    assert((p > 0 || sNamePrefix === "") && mUrlPrefixes[sNamePrefix], "there always must be a mapping");
    sPath = mUrlPrefixes[sNamePrefix].url + sResourceName.slice(p + 1);
    if (sPath.slice(-1) === "/") {
      sPath = sPath.slice(0, -1);
    }
    return sPath + (sSuffix || "");
  }
  function getSyncCallBehavior() {
    return syncCallBehavior;
  }
  function guessResourceName(sURL) {
    var sNamePrefix, sUrlPrefix, sResourceName;
    sURL = pathOnly(resolveURL(sURL));
    for (sNamePrefix in mUrlPrefixes) {
      sUrlPrefix = mUrlPrefixes[sNamePrefix].absoluteUrl.slice(0, -1);
      if (sURL.indexOf(sUrlPrefix) === 0) {
        sResourceName = sNamePrefix + sURL.slice(sUrlPrefix.length);
        if (sResourceName.charAt(0) === "/") {
          sResourceName = sResourceName.slice(1);
        }
        if (mModules[sResourceName] && mModules[sResourceName].data) {
          return sResourceName;
        }
      }
    }
  }
  function findMapForContext(sContext) {
    var p, mMap;
    if (sContext != null) {
      sContext = urnToIDAndType(sContext).id;
      p = sContext.length;
      mMap = mMaps[sContext];
      while (p > 0 && mMap == null) {
        p = sContext.lastIndexOf("/");
        if (p > 0) {
          sContext = sContext.slice(0, p);
          mMap = mMaps[sContext];
        }
      }
    }
    return mMap || mMaps["*"];
  }
  function getMappedName(sResourceName, sRequestingResourceName) {
    var mMap = findMapForContext(sRequestingResourceName), sPrefix, p;
    sResourceName = normalize(sResourceName, sRequestingResourceName);
    if (mMap != null) {
      sPrefix = urnToIDAndType(sResourceName).id;
      p = sPrefix.length;
      while (p > 0 && mMap[sPrefix] == null) {
        p = sPrefix.lastIndexOf("/");
        sPrefix = p > 0 ? sPrefix.slice(0, p) : "";
      }
      if (p > 0) {
        if (log.isLoggable()) {
          log.debug("module ID " + sResourceName + " mapped to " + mMap[sPrefix] + sResourceName.slice(p));
        }
        return mMap[sPrefix] + sResourceName.slice(p);
      }
    }
    return sResourceName;
  }
  function getGlobalObject(oObject, aNames, l, bCreate) {
    for (var i = 0; oObject && i < l; i++) {
      if (!oObject[aNames[i]] && bCreate) {
        oObject[aNames[i]] = {};
      }
      oObject = oObject[aNames[i]];
    }
    return oObject;
  }
  function getGlobalProperty(sName) {
    var aNames = sName ? sName.split(".") : [];
    if (syncCallBehavior && aNames.length > 1) {
      log.error("[nosync] getGlobalProperty called to retrieve global name '" + sName + "'");
    }
    return getGlobalObject(__global, aNames, aNames.length);
  }
  function setGlobalProperty(sName, vValue) {
    var aNames = sName ? sName.split(".") : [], oObject;
    if (aNames.length > 0) {
      oObject = getGlobalObject(__global, aNames, aNames.length - 1, true);
      oObject[aNames[aNames.length - 1]] = vValue;
    }
  }
  var INITIAL = 0, PRELOADED = -1, LOADING = 1, LOADED = 2, EXECUTING = 3, READY = 4, FAILED = 5, NOT_YET_DETERMINED = {};
  function Module(name) {
    this.name = name;
    this.state = INITIAL;
    this.settled = false;
    this.url = this._deferred = this.data = this.group = this.error = this.pending = null;
    this.content = NOT_YET_DETERMINED;
  }
  Module.prototype.deferred = function () {
    if (this._deferred == null) {
      var deferred = this._deferred = {};
      deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
      });
      deferred.promise.catch(noop);
    }
    return this._deferred;
  };
  Module.prototype.api = function () {
    if (this._api == null) {
      this._exports = {};
      this._api = {
        id: this.name.slice(0, -3),
        exports: this._exports,
        url: this.url,
        config: noop
      };
    }
    return this._api;
  };
  Module.prototype.ready = function (value) {
    assert(!this.settled, "Module " + this.name + " is already settled");
    this.state = READY;
    this.settled = true;
    if (arguments.length > 0) {
      this.content = value;
    }
    this.deferred().resolve(this.value());
    if (this.aliases) {
      value = this.value();
      this.aliases.forEach(function (alias) {
        Module.get(alias).ready(value);
      });
    }
  };
  Module.prototype.fail = function (err) {
    assert(!this.settled, "Module " + this.name + " is already settled");
    this.settled = true;
    if (this.state !== FAILED) {
      this.state = FAILED;
      this.error = err;
      this.deferred().reject(err);
      if (this.aliases) {
        this.aliases.forEach(function (alias) {
          Module.get(alias).fail(err);
        });
      }
    }
  };
  Module.prototype.addPending = function (sDependency) {
    (this.pending || (this.pending = [])).push(sDependency);
  };
  Module.prototype.addAlias = function (sAliasName) {
    (this.aliases || (this.aliases = [])).push(sAliasName);
    Module.get(sAliasName).addPending(this.name);
  };
  Module.prototype.preload = function (url, data, bundle) {
    if (this.state === INITIAL && !(fnIgnorePreload && fnIgnorePreload(this.name))) {
      this.state = PRELOADED;
      this.url = url;
      this.data = data;
      this.group = bundle;
    }
    return this;
  };
  Module.prototype.value = function () {
    if (this.state === READY) {
      if (this.content === NOT_YET_DETERMINED) {
        var oShim = mShims[this.name], sExport = oShim && (Array.isArray(oShim.exports) ? oShim.exports[0] : oShim.exports);
        this.content = getGlobalProperty(sExport || urnToUI5(this.name));
      }
      return this.content;
    }
    return undefined;
  };
  Module.prototype.dependsOn = function (oDependantModule) {
    var dependant = oDependantModule.name, visited = Object.create(null);
    function visit(mod) {
      if (!visited[mod]) {
        visited[mod] = true;
        var pending = mModules[mod] && mModules[mod].pending;
        return Array.isArray(pending) && (pending.indexOf(dependant) >= 0 || pending.some(visit));
      }
      return false;
    }
    return this.name === dependant || visit(this.name);
  };
  Module.get = function (sModuleName) {
    return mModules[sModuleName] || (mModules[sModuleName] = new Module(sModuleName));
  };
  function ensureStacktrace(oError) {
    if (!oError.stack) {
      try {
        throw oError;
      } catch (ex) {
        return ex;
      }
    }
    return oError;
  }
  function makeNestedError(msg, cause) {
    var oError = new Error(msg + ": " + cause.message);
    oError.cause = cause;
    oError.loadError = cause.loadError;
    ensureStacktrace(oError);
    ensureStacktrace(cause);
    if (oError.stack && cause.stack) {
      try {
        oError.stack = oError.stack + "\nCaused by: " + cause.stack;
      } catch (err) {}
    }
    return oError;
  }
  function declareModule(sModuleName) {
    var oModule;
    assert((/\.js$/).test(sModuleName), "must be a Javascript module");
    oModule = Module.get(sModuleName);
    if (oModule.state > INITIAL) {
      return oModule;
    }
    if (log.isLoggable()) {
      log.debug(sLogPrefix + "declare module '" + sModuleName + "'");
    }
    oModule.state = READY;
    return oModule;
  }
  function defineModuleSync(sResourceName, vValue) {
    Module.get(sResourceName).ready(vValue);
  }
  var queue = new (function ModuleDefinitionQueue() {
    var aQueue = [], iRun = 0, vTimer;
    this.push = function (name, deps, factory, _export) {
      if (log.isLoggable()) {
        log.debug("pushing define from " + (document.currentScript && document.currentScript.src));
      }
      aQueue.push({
        name: name,
        deps: deps,
        factory: factory,
        _export: _export,
        guess: document.currentScript && document.currentScript.getAttribute("data-sap-ui-module")
      });
      if (!vTimer) {
        vTimer = setTimeout(this.process.bind(this, null));
      }
    };
    this.clear = function () {
      aQueue = [];
      if (vTimer) {
        clearTimeout(vTimer);
        vTimer = null;
      }
    };
    this.process = function (oRequestedModule) {
      var bLoggable = log.isLoggable(), iCurrentRun = iRun++, aQueueCopy = aQueue, sModuleName = null;
      this.clear();
      if (oRequestedModule) {
        if (oRequestedModule.execError) {
          if (bLoggable) {
            log.debug("module execution error detected, ignoring queued define calls (" + aQueueCopy.length + ")");
          }
          oRequestedModule.fail(oRequestedModule.execError);
          return;
        }
      }
      sModuleName = oRequestedModule && oRequestedModule.name;
      aQueueCopy.forEach(function (oEntry) {
        if (oEntry.name == null) {
          if (sModuleName != null) {
            oEntry.name = sModuleName;
            sModuleName = null;
          } else {
            if (strictModuleDefinitions) {
              var oError = new Error("Modules that use an anonymous define() call must be loaded with a require() call; " + "they must not be executed via script tag or nested into other modules. ");
              if (oRequestedModule) {
                oRequestedModule.fail(oError);
              } else {
                throw oError;
              }
            }
            oEntry.name = "~anonymous~" + ++iAnonymousModuleCount + ".js";
            log.error("Modules that use an anonymous define() call must be loaded with a require() call; " + "they must not be executed via script tag or nested into other modules. " + "All other usages will fail in future releases or when standard AMD loaders are used. " + "Now using substitute name " + oEntry.name);
          }
        } else if (oRequestedModule && oEntry.name === oRequestedModule.name) {
          if (sModuleName == null && !strictModuleDefinitions) {
            log.error("Duplicate module definition: both, an unnamed module and a module with the expected name exist." + "This use case will fail in future releases or when standard AMD loaders are used. ");
          }
          sModuleName = null;
        }
      });
      if (sModuleName && aQueueCopy.length > 0) {
        if (bLoggable) {
          log.debug("No queued module definition matches the ID of the request. " + "Now assuming that the first definition '" + aQueueCopy[0].name + "' is an alias of '" + sModuleName + "'");
        }
        Module.get(aQueueCopy[0].name).addAlias(sModuleName);
        sModuleName = null;
      }
      if (bLoggable) {
        log.debug("processing define queue " + iCurrentRun + (oRequestedModule ? " for " + oRequestedModule.name : "") + " with " + aQueueCopy.map(function (entry) {
          return entry.name;
        }));
      }
      aQueueCopy.forEach(function (oEntry) {
        executeModuleDefinition(oEntry.name, oEntry.deps, oEntry.factory, oEntry._export, true);
        if (bLoggable) {
          log.debug("define called for " + oEntry.name);
        }
      });
      if (sModuleName != null && !oRequestedModule.settled) {
        if (bLoggable) {
          log.debug("no queued module definition for the requested module found, assume the module to be ready");
        }
        oRequestedModule.data = undefined;
        oRequestedModule.ready();
      }
      if (bLoggable) {
        log.debug("processing define queue done " + iCurrentRun);
      }
    };
  })();
  function loadSyncXHR(oModule) {
    var xhr = new XMLHttpRequest();
    function enrichXHRError(error) {
      error = error || ensureStacktrace(new Error(xhr.status + " - " + xhr.statusText));
      error.status = xhr.status;
      error.statusText = xhr.statusText;
      error.loadError = true;
      return error;
    }
    xhr.addEventListener("load", function (e) {
      if (xhr.status === 200 || xhr.status === 0) {
        oModule.state = LOADED;
        oModule.data = xhr.responseText;
      } else {
        oModule.error = enrichXHRError();
      }
    });
    xhr.addEventListener("error", function (e) {
      oModule.error = enrichXHRError();
    });
    xhr.open("GET", oModule.url, false);
    try {
      xhr.send();
    } catch (error) {
      oModule.error = enrichXHRError(error);
    }
  }
  if (("currentScript" in document)) {
    window.addEventListener("error", function onUncaughtError(errorEvent) {
      var sModuleName = document.currentScript && document.currentScript.getAttribute("data-sap-ui-module");
      var oModule = sModuleName && Module.get(sModuleName);
      if (oModule && oModule.execError == null) {
        if (log.isLoggable()) {
          log.debug("unhandled exception occurred while executing " + sModuleName + ": " + errorEvent.message);
        }
        oModule.execError = errorEvent.error || ({
          name: "Error",
          message: errorEvent.message
        });
        return false;
      }
    });
  }
  function loadScript(oModule, sAlternativeURL) {
    var oScript;
    function onload(e) {
      if (log.isLoggable()) {
        log.debug("Javascript resource loaded: " + oModule.name);
      }
      oScript.removeEventListener("load", onload);
      oScript.removeEventListener("error", onerror);
      queue.process(oModule);
    }
    function onerror(e) {
      oScript.removeEventListener("load", onload);
      oScript.removeEventListener("error", onerror);
      if (sAlternativeURL) {
        log.warning("retry loading Javascript resource: " + oModule.name);
        if (oScript && oScript.parentNode) {
          oScript.parentNode.removeChild(oScript);
        }
        oModule.url = sAlternativeURL;
        loadScript(oModule, null);
        return;
      }
      log.error("failed to load Javascript resource: " + oModule.name);
      oModule.fail(ensureStacktrace(new Error("failed to load '" + oModule.name + "' from " + oModule.url + ": script load error")));
    }
    oScript = document.createElement("SCRIPT");
    oScript["s" + "rc"] = oModule.url;
    oScript.setAttribute("data-sap-ui-module", oModule.name);
    if (sAlternativeURL !== undefined) {
      oScript.addEventListener("load", onload);
      oScript.addEventListener("error", onerror);
    }
    document.head.appendChild(oScript);
  }
  function preloadDependencies(sModuleName) {
    var knownDependencies = mDepCache[sModuleName];
    if (Array.isArray(knownDependencies)) {
      log.debug("preload dependencies for " + sModuleName + ": " + knownDependencies);
      knownDependencies.forEach(function (dep) {
        dep = getMappedName(dep, sModuleName);
        if ((/\.js$/).test(dep)) {
          requireModule(null, dep, true);
        }
      });
    }
  }
  function requireModule(oRequestingModule, sModuleName, bAsync, bSkipShimDeps) {
    var bLoggable = log.isLoggable(), oSplitName = urnToBaseIDAndSubType(sModuleName), oShim = mShims[sModuleName], oModule, aExtensions, i, sMsg, bExecutedNow;
    if (!oSplitName) {
      throw new Error("can only require Javascript module, not " + sModuleName);
    }
    if (sModuleName[0] == "/") {
      log.error("Module names that start with a slash should not be used, as they are reserved for future use.");
    }
    oModule = Module.get(sModuleName);
    if (oShim && oShim.deps && !bSkipShimDeps) {
      if (bLoggable) {
        log.debug("require dependencies of raw module " + sModuleName);
      }
      return requireAll(oModule, oShim.deps, function () {
        return requireModule(oRequestingModule, sModuleName, bAsync, true);
      }, function (oErr) {
        oModule.fail(oErr);
        if (bAsync) {
          return;
        }
        throw oErr;
      }, bAsync);
    }
    if (bLoggable) {
      log.debug(sLogPrefix + "require '" + sModuleName + "' of type '" + oSplitName.subType + "'");
    }
    if (oModule.state !== INITIAL) {
      if (oModule.state === PRELOADED) {
        oModule.state = LOADED;
        oModule.async = bAsync;
        bExecutedNow = true;
        measure && measure.start(sModuleName, "Require module " + sModuleName + " (preloaded)", ["require"]);
        execModule(sModuleName, bAsync);
        measure && measure.end(sModuleName);
      }
      if (oModule.state === READY) {
        if (bLoggable) {
          log.debug(sLogPrefix + "module '" + sModuleName + "' has already been loaded (skipped).");
        }
        return bAsync ? Promise.resolve(oModule.value()) : oModule.value();
      } else if (oModule.state === FAILED) {
        if (bAsync) {
          return oModule.deferred().promise;
        } else {
          throw bExecutedNow ? oModule.error : makeNestedError("found in negative cache: '" + sModuleName + "' from " + oModule.url, oModule.error);
        }
      } else {
        if (bAsync) {
          if (oRequestingModule && oModule.dependsOn(oRequestingModule)) {
            if (log.isLoggable()) {
              log.debug("cycle detected between '" + oRequestingModule.name + "' and '" + sModuleName + "', returning undefined for '" + sModuleName + "'");
            }
            return Promise.resolve(undefined);
          }
          return oModule.deferred().promise;
        }
        if (!bAsync && !oModule.async) {
          if (log.isLoggable()) {
            log.debug("cycle detected between '" + (oRequestingModule ? oRequestingModule.name : "unknown") + "' and '" + sModuleName + "', returning undefined for '" + sModuleName + "'");
          }
          return undefined;
        }
        log.warning("Sync request triggered for '" + sModuleName + "' while async request was already pending." + " Loading a module twice might cause issues and should be avoided by fully migrating to async APIs.");
      }
    }
    measure && measure.start(sModuleName, "Require module " + sModuleName, ["require"]);
    oModule.state = LOADING;
    oModule.async = bAsync;
    aExtensions = bDebugSources ? ["-dbg", ""] : [""];
    if (!bAsync) {
      for (i = 0; i < aExtensions.length && oModule.state !== LOADED; i++) {
        oModule.url = getResourcePath(oSplitName.baseID, aExtensions[i] + oSplitName.subType);
        if (bLoggable) {
          log.debug(sLogPrefix + "loading " + (aExtensions[i] ? aExtensions[i] + " version of " : "") + "'" + sModuleName + "' from '" + oModule.url + "'");
        }
        if (syncCallBehavior) {
          sMsg = "[nosync] loading module '" + oModule.url + "'";
          if (syncCallBehavior === 1) {
            log.error(sMsg);
          } else {
            throw new Error(sMsg);
          }
        }
        ui5Require.load({
          completeLoad: noop,
          async: false
        }, oModule.url, oSplitName.baseID);
        loadSyncXHR(oModule);
      }
      if (oModule.state === LOADING) {
        oModule.fail(makeNestedError("failed to load '" + sModuleName + "' from " + oModule.url, oModule.error));
      } else if (oModule.state === LOADED) {
        execModule(sModuleName, bAsync);
      }
      measure && measure.end(sModuleName);
      if (oModule.state !== READY) {
        if (fnIgnorePreload) {
          loadScript(oModule);
        }
        throw oModule.error;
      }
      return oModule.value();
    } else {
      oModule.url = getResourcePath(oSplitName.baseID, aExtensions[0] + oSplitName.subType);
      var sAltUrl = bDebugSources ? getResourcePath(oSplitName.baseID, aExtensions[1] + oSplitName.subType) : oModule.url;
      ui5Require.load({
        completeLoad: noop,
        async: true
      }, sAltUrl, oSplitName.baseID);
      loadScript(oModule, sAltUrl);
      preloadDependencies(sModuleName);
      return oModule.deferred().promise;
    }
  }
  function execModule(sModuleName, bAsync) {
    var oModule = mModules[sModuleName], oShim = mShims[sModuleName], bLoggable = log.isLoggable(), sOldPrefix, sScript, vAMD, oMatch, bOldForceSyncDefines;
    if (oModule && oModule.state === LOADED && typeof oModule.data !== "undefined") {
      vAMD = (oShim === true || oShim && oShim.amd) && typeof __global.define === "function" && __global.define.amd;
      bOldForceSyncDefines = bForceSyncDefines;
      try {
        if (vAMD) {
          delete __global.define.amd;
        }
        bForceSyncDefines = !bAsync;
        if (bLoggable) {
          log.debug(sLogPrefix + "executing '" + sModuleName + "'");
          sOldPrefix = sLogPrefix;
          sLogPrefix = sLogPrefix + ": ";
        }
        oModule.state = EXECUTING;
        _execStack.push({
          name: sModuleName,
          used: false
        });
        if (typeof oModule.data === "function") {
          oModule.data.call(__global);
        } else if (Array.isArray(oModule.data)) {
          ui5Define.apply(null, oModule.data);
        } else {
          sScript = oModule.data;
          if (sScript) {
            oMatch = (/\/\/[#@] source(Mapping)?URL=(.*)$/).exec(sScript);
            if (oMatch && oMatch[1] && (/^[^/]+\.js\.map$/).test(oMatch[2])) {
              sScript = sScript.slice(0, oMatch.index) + oMatch[0].slice(0, -oMatch[2].length) + resolveURL(oMatch[2], oModule.url);
            }
            if (!oMatch || oMatch[1]) {
              sScript += "\n//# sourceURL=" + resolveURL(oModule.url) + "?eval";
            }
          }
          if (typeof translate === "function") {
            sScript = translate(sScript, sModuleName);
          }
          if (__global.execScript && (!oModule.data || oModule.data.length < MAX_EXEC_SCRIPT_LENGTH)) {
            try {
              oModule.data && __global.execScript(sScript);
            } catch (e) {
              _execStack.pop();
              eval(oModule.data);
              throw e;
            }
          } else {
            __global.eval(sScript);
          }
        }
        _execStack.pop();
        queue.process(oModule);
        if (bLoggable) {
          sLogPrefix = sOldPrefix;
          log.debug(sLogPrefix + "finished executing '" + sModuleName + "'");
        }
      } catch (err) {
        if (bLoggable) {
          sLogPrefix = sOldPrefix;
        }
        oModule.data = undefined;
        oModule.fail(err);
      } finally {
        if (vAMD) {
          __global.define.amd = vAMD;
        }
        bForceSyncDefines = bOldForceSyncDefines;
      }
    }
  }
  function requireAll(oRequestingModule, aDependencies, fnCallback, fnErrCallback, bAsync) {
    var sBaseName, aModules = [], bLoggable = log.isLoggable(), i, sDepModName, oError, oPromise;
    try {
      if (oRequestingModule instanceof Module) {
        sBaseName = oRequestingModule.name;
      } else {
        sBaseName = oRequestingModule;
        oRequestingModule = null;
      }
      aDependencies = aDependencies.slice();
      for (i = 0; i < aDependencies.length; i++) {
        aDependencies[i] = getMappedName(aDependencies[i] + ".js", sBaseName);
      }
      if (oRequestingModule) {
        aDependencies.forEach(function (dep) {
          if (!(/^(require|exports|module)\.js$/).test(dep)) {
            oRequestingModule.addPending(dep);
          }
        });
      }
      for (i = 0; i < aDependencies.length; i++) {
        sDepModName = aDependencies[i];
        if (bLoggable) {
          log.debug(sLogPrefix + "require '" + sDepModName + "'");
        }
        if (oRequestingModule) {
          switch (sDepModName) {
            case "require.js":
              aModules[i] = createContextualRequire(sBaseName, true);
              break;
            case "module.js":
              aModules[i] = oRequestingModule.api();
              break;
            case "exports.js":
              oRequestingModule.api();
              aModules[i] = oRequestingModule._exports;
              break;
            default:
              break;
          }
        }
        if (!aModules[i]) {
          aModules[i] = requireModule(oRequestingModule, sDepModName, bAsync);
        }
        if (bLoggable) {
          log.debug(sLogPrefix + "require '" + sDepModName + "': done.");
        }
      }
    } catch (err) {
      oError = err;
    }
    if (bAsync) {
      oPromise = oError ? Promise.reject(oError) : Promise.all(aModules);
      return oPromise.then(fnCallback, fnErrCallback);
    } else {
      if (oError) {
        fnErrCallback(oError);
      } else {
        return fnCallback(aModules);
      }
    }
  }
  function executeModuleDefinition(sResourceName, aDependencies, vFactory, bExport, bAsync) {
    var bLoggable = log.isLoggable();
    sResourceName = normalize(sResourceName);
    if (bLoggable) {
      log.debug("define(" + sResourceName + ", " + "['" + aDependencies.join("','") + "']" + ")");
    }
    var oModule = declareModule(sResourceName);
    var repeatedExecutionReported = false;
    function shouldSkipExecution() {
      if (oModule.settled) {
        if (oModule.state >= READY && bAsync && oModule.async === false) {
          log.warning("Repeated module execution skipped after async/sync conflict for " + oModule.name);
          return true;
        }
        if (strictModuleDefinitions && bAsync) {
          log.warning("Module '" + oModule.name + "' has been defined more than once. " + "All but the first definition will be ignored, don't try to define the same module again.");
          return true;
        }
        if (!repeatedExecutionReported) {
          log.error("Module '" + oModule.name + "' is executed more than once. " + "This is an unsupported scenario and will fail in future versions of UI5 or " + "when a standard AMD loader is used. Don't define the same module again.");
          repeatedExecutionReported = true;
        }
      }
    }
    if (shouldSkipExecution()) {
      return;
    }
    oModule.content = undefined;
    requireAll(oModule, aDependencies, function (aModules) {
      if (shouldSkipExecution()) {
        return;
      }
      if (bLoggable) {
        log.debug("define(" + sResourceName + "): calling factory " + typeof vFactory);
      }
      if (bExport && syncCallBehavior !== 2) {
        var aPackages = sResourceName.split("/");
        if (aPackages.length > 1) {
          getGlobalObject(__global, aPackages, aPackages.length - 1, true);
        }
      }
      if (typeof vFactory === "function") {
        try {
          var exports = vFactory.apply(__global, aModules);
          if (oModule._api && oModule._api.exports !== undefined && oModule._api.exports !== oModule._exports) {
            exports = oModule._api.exports;
          } else if (exports === undefined && oModule._exports) {
            exports = oModule._exports;
          }
          oModule.content = exports;
        } catch (error) {
          oModule.fail(error);
          if (bAsync) {
            return;
          }
          throw error;
        }
      } else {
        oModule.content = vFactory;
      }
      if (bExport && syncCallBehavior !== 2) {
        if (oModule.content == null) {
          log.error("Module '" + sResourceName + "' returned no content, but should export to global?");
        } else {
          if (bLoggable) {
            log.debug("exporting content of '" + sResourceName + "': as global object");
          }
          var sModuleName = urnToUI5(sResourceName);
          setGlobalProperty(sModuleName, oModule.content);
        }
      }
      oModule.ready();
    }, function (oErr) {
      oModule.fail(oErr);
      if (!bAsync) {
        throw oErr;
      }
    }, bAsync);
  }
  function ui5Define(sModuleName, aDependencies, vFactory, bExport) {
    var sResourceName, oCurrentExecInfo;
    if (typeof sModuleName === "string") {
      sResourceName = sModuleName + ".js";
    } else {
      bExport = vFactory;
      vFactory = aDependencies;
      aDependencies = sModuleName;
      sResourceName = null;
    }
    if (!Array.isArray(aDependencies)) {
      bExport = vFactory;
      vFactory = aDependencies;
      if (typeof vFactory === "function" && vFactory.length > 0) {
        aDependencies = ["require", "exports", "module"].slice(0, vFactory.length);
      } else {
        aDependencies = [];
      }
    }
    if (bForceSyncDefines === false || bForceSyncDefines == null && bGlobalAsyncMode) {
      queue.push(sResourceName, aDependencies, vFactory, bExport);
      if (sResourceName != null) {
        var oModule = Module.get(sResourceName);
        if (oModule.state === INITIAL) {
          oModule.state = EXECUTING;
          oModule.async = true;
        }
      }
      return;
    }
    oCurrentExecInfo = _execStack.length > 0 ? _execStack[_execStack.length - 1] : null;
    if (!sResourceName) {
      if (oCurrentExecInfo && !oCurrentExecInfo.used) {
        sResourceName = oCurrentExecInfo.name;
        oCurrentExecInfo.used = true;
      } else {
        sResourceName = "~anonymous~" + ++iAnonymousModuleCount + ".js";
        if (oCurrentExecInfo) {
          sResourceName = oCurrentExecInfo.name.slice(0, oCurrentExecInfo.name.lastIndexOf("/") + 1) + sResourceName;
        }
        log.error("Modules that use an anonymous define() call must be loaded with a require() call; " + "they must not be executed via script tag or nested into other modules. " + "All other usages will fail in future releases or when standard AMD loaders are used " + "or when ui5loader runs in async mode. Now using substitute name " + sResourceName);
      }
    } else if (oCurrentExecInfo && !oCurrentExecInfo.used && sResourceName !== oCurrentExecInfo.name) {
      log.debug("module names don't match: requested: " + sModuleName + ", defined: ", oCurrentExecInfo.name);
      Module.get(oCurrentExecInfo.name).addAlias(sModuleName);
    }
    executeModuleDefinition(sResourceName, aDependencies, vFactory, bExport, false);
  }
  function amdDefine(sModuleName, aDependencies, vFactory) {
    var oArgs = arguments;
    var bExportIsSet = typeof oArgs[oArgs.length - 1] === "boolean";
    if (bExportIsSet) {
      oArgs = Array.prototype.slice.call(oArgs, 0, oArgs.length - 1);
    }
    ui5Define.apply(this, oArgs);
  }
  amdDefine.amd = {};
  function createContextualRequire(sContextName, bAMDCompliance) {
    var fnRequire = function (vDependencies, fnCallback, fnErrCallback) {
      var sModuleName;
      assert(typeof vDependencies === "string" || Array.isArray(vDependencies), "dependency param either must be a single string or an array of strings");
      assert(fnCallback == null || typeof fnCallback === "function", "callback must be a function or null/undefined");
      assert(fnErrCallback == null || typeof fnErrCallback === "function", "error callback must be a function or null/undefined");
      if (typeof vDependencies === "string") {
        sModuleName = getMappedName(vDependencies + ".js", sContextName);
        var oModule = Module.get(sModuleName);
        if (bAMDCompliance && oModule.state !== EXECUTING && oModule.state !== READY) {
          throw new Error("Module '" + sModuleName + "' has not been loaded yet. " + "Use require(['" + sModuleName + "']) to load it.");
        }
        return oModule.value();
      }
      requireAll(sContextName, vDependencies, function (aModules) {
        if (typeof fnCallback === "function") {
          if (bGlobalAsyncMode) {
            fnCallback.apply(__global, aModules);
          } else {
            setTimeout(function () {
              fnCallback.apply(__global, aModules);
            }, 0);
          }
        }
      }, function (oErr) {
        if (typeof fnErrCallback === "function") {
          if (bGlobalAsyncMode) {
            fnErrCallback.call(__global, oErr);
          } else {
            setTimeout(function () {
              fnErrCallback.call(__global, oErr);
            }, 0);
          }
        } else {
          throw oErr;
        }
      }, bGlobalAsyncMode);
    };
    fnRequire.toUrl = function (sName) {
      var sMappedName = ensureTrailingSlash(getMappedName(sName, sContextName), sName);
      return toUrl(sMappedName);
    };
    return fnRequire;
  }
  function ensureTrailingSlash(sName, sInput) {
    if (sInput.slice(-1) === "/" && sName.slice(-1) !== "/") {
      return sName + "/";
    }
    return sName;
  }
  function toUrl(sName) {
    if (sName.indexOf("/") === 0) {
      throw new Error("The provided argument '" + sName + "' may not start with a slash");
    }
    return ensureTrailingSlash(getResourcePath(sName), sName);
  }
  var ui5Require = createContextualRequire(null, false);
  var amdRequire = createContextualRequire(null, true);
  function requireSync(sModuleName) {
    sModuleName = getMappedName(sModuleName + ".js");
    return requireModule(null, sModuleName, false);
  }
  function predefine(sModuleName, aDependencies, vFactory, bExport) {
    if (typeof sModuleName !== "string") {
      throw new Error("predefine requires a module name");
    }
    sModuleName = normalize(sModuleName);
    Module.get(sModuleName + ".js").preload("<unknown>/" + sModuleName, [sModuleName, aDependencies, vFactory, bExport], null);
  }
  function preload(modules, group, url) {
    group = group || null;
    url = url || "<unknown>";
    for (var name in modules) {
      name = normalize(name);
      Module.get(name).preload(url + "/" + name, modules[name], group);
    }
  }
  function dumpInternals(iThreshold) {
    var states = [PRELOADED, INITIAL, LOADED, READY, FAILED, EXECUTING, LOADING];
    var stateNames = {};
    stateNames[PRELOADED] = "PRELOADED";
    stateNames[INITIAL] = "INITIAL";
    stateNames[LOADING] = "LOADING";
    stateNames[LOADED] = "LOADED";
    stateNames[EXECUTING] = "EXECUTING";
    stateNames[READY] = "READY";
    stateNames[FAILED] = "FAILED";
    if (iThreshold == null) {
      iThreshold = PRELOADED;
    }
    var info = log.isLoggable("INFO") ? log.info.bind(log) : console.info.bind(console);
    var aModuleNames = Object.keys(mModules).sort();
    states.forEach(function (state) {
      if (state < iThreshold) {
        return;
      }
      var count = 0;
      info(stateNames[state] + ":");
      aModuleNames.forEach(function (sModule, idx) {
        var oModule = mModules[sModule];
        if (oModule.state === state) {
          var addtlInfo;
          if (oModule.state === LOADING) {
            var pending = oModule.pending && oModule.pending.reduce(function (acc, dep) {
              var oDepModule = Module.get(dep);
              if (oDepModule.state !== READY) {
                acc.push(dep + "(" + stateNames[oDepModule.state] + ")");
              }
              return acc;
            }, []);
            if (pending && pending.length > 0) {
              addtlInfo = "waiting for " + pending.join(", ");
            }
          } else if (oModule.state === FAILED) {
            addtlInfo = (oModule.error.name || "Error") + ": " + oModule.error.message;
          }
          info("  " + (idx + 1) + " " + sModule + (addtlInfo ? " (" + addtlInfo + ")" : ""));
          count++;
        }
      });
      if (count === 0) {
        info("  none");
      }
    });
  }
  function getUrlPrefixes() {
    var mUrlPrefixesCopy = Object.create(null);
    forEach(mUrlPrefixes, function (sNamePrefix, oUrlInfo) {
      mUrlPrefixesCopy[sNamePrefix] = oUrlInfo.url;
    });
    return mUrlPrefixesCopy;
  }
  function unloadResources(sName, bPreloadGroup, bUnloadAll, bDeleteExports) {
    var aModules = [], sURN, oModule;
    if (bPreloadGroup == null) {
      bPreloadGroup = true;
    }
    if (bPreloadGroup) {
      for (sURN in mModules) {
        oModule = mModules[sURN];
        if (oModule && oModule.group === sName) {
          aModules.push(sURN);
        }
      }
    } else {
      if (mModules[sName]) {
        aModules.push(sName);
      }
    }
    aModules.forEach(function (sURN) {
      var oModule = mModules[sURN];
      if (oModule && bDeleteExports && sURN.match(/\.js$/)) {
        setGlobalProperty(urnToUI5(sURN), undefined);
      }
      if (oModule && (bUnloadAll || oModule.state === PRELOADED)) {
        delete mModules[sURN];
      }
    });
  }
  function getModuleContent(name, url) {
    if (name) {
      name = getMappedName(name);
    } else {
      name = guessResourceName(url);
    }
    var oModule = name && mModules[name];
    if (oModule) {
      oModule.state = LOADED;
      return oModule.data;
    } else {
      return undefined;
    }
  }
  function getAllModules() {
    var mSnapshot = Object.create(null);
    forEach(mModules, function (sURN, oModule) {
      mSnapshot[sURN] = {
        state: oModule.state,
        ui5: urnToUI5(sURN)
      };
    });
    return mSnapshot;
  }
  function loadJSResourceAsync(sResource, bIgnoreErrors) {
    sResource = getMappedName(sResource);
    var promise = requireModule(null, sResource, true);
    return bIgnoreErrors ? promise.catch(noop) : promise;
  }
  var mUI5ConfigHandlers = {
    baseUrl: function (url) {
      registerResourcePath("", url);
    },
    paths: registerResourcePath,
    shim: function (module, shim) {
      if (Array.isArray(shim)) {
        shim = {
          deps: shim
        };
      }
      mShims[module + ".js"] = shim;
    },
    amd: function (bValue) {
      bValue = !!bValue;
      if (bExposeAsAMDLoader !== bValue) {
        bExposeAsAMDLoader = bValue;
        if (bValue) {
          vOriginalDefine = __global.define;
          vOriginalRequire = __global.require;
          __global.define = amdDefine;
          __global.require = amdRequire;
          bGlobalAsyncMode = true;
        } else {
          __global.define = vOriginalDefine;
          __global.require = vOriginalRequire;
        }
      }
    },
    async: function (async) {
      if (bGlobalAsyncMode && !async) {
        throw new Error("Changing the ui5loader config from async to sync is not supported. Only a change from sync to async is allowed.");
      }
      bGlobalAsyncMode = !!async;
    },
    debugSources: function (debug) {
      bDebugSources = !!debug;
    },
    depCache: function (module, deps) {
      mDepCache[module + ".js"] = deps.map(function (dep) {
        return dep + ".js";
      });
    },
    depCacheUI5: function (module, deps) {
      mDepCache[module] = deps;
    },
    ignoreBundledResources: function (filter) {
      if (filter == null || typeof filter === "function") {
        fnIgnorePreload = filter;
      }
    },
    map: function (context, map) {
      if (map == null) {
        delete mMaps[context];
      } else if (typeof map === "string") {
        mMaps["*"][context] = map;
      } else {
        mMaps[context] = mMaps[context] || Object.create(null);
        forEach(map, function (alias, name) {
          mMaps[context][alias] = name;
        });
      }
    },
    reportSyncCalls: function (report) {
      if (report === 0 || report === 1 || report === 2) {
        syncCallBehavior = report;
      }
    },
    noConflict: function (bValue) {
      log.warning("Config option 'noConflict' has been deprecated, use option 'amd' instead, if still needed.");
      mUI5ConfigHandlers.amd(!bValue);
    }
  };
  var mAMDConfigHandlers = {
    baseUrl: mUI5ConfigHandlers.baseUrl,
    paths: function (module, url) {
      registerResourcePath(module, resolveURL(url, getResourcePath("") + "/"));
    },
    map: mUI5ConfigHandlers.map,
    shim: mUI5ConfigHandlers.shim
  };
  function handleConfigObject(oCfg, mHandlers) {
    function processConfig(key, value) {
      var handler = mHandlers[key];
      if (typeof handler === "function") {
        if (handler.length === 1) {
          handler(value);
        } else if (value != null) {
          forEach(value, handler);
        }
      } else {
        log.warning("configuration option " + key + " not supported (ignored)");
      }
    }
    if (oCfg.baseUrl) {
      processConfig("baseUrl", oCfg.baseUrl);
    }
    forEach(oCfg, function (key, value) {
      if (key !== "baseUrl") {
        processConfig(key, value);
      }
    });
  }
  function ui5Config(cfg) {
    if (cfg === undefined) {
      return {
        amd: bExposeAsAMDLoader,
        async: bGlobalAsyncMode,
        noConflict: !bExposeAsAMDLoader
      };
    }
    handleConfigObject(cfg, mUI5ConfigHandlers);
  }
  function amdConfig(cfg) {
    if (cfg === undefined) {
      return undefined;
    }
    handleConfigObject(cfg, mAMDConfigHandlers);
  }
  ui5Require.preload = preload;
  ui5Require.load = function (context, url, id) {};
  var privateAPI = {
    amdDefine: amdDefine,
    amdRequire: amdRequire,
    config: ui5Config,
    declareModule: function (sResourceName) {
      declareModule(normalize(sResourceName));
    },
    defineModuleSync: defineModuleSync,
    dump: dumpInternals,
    getAllModules: getAllModules,
    getModuleContent: getModuleContent,
    getModuleState: function (sResourceName) {
      return mModules[sResourceName] ? mModules[sResourceName].state : INITIAL;
    },
    getResourcePath: getResourcePath,
    getSyncCallBehavior: getSyncCallBehavior,
    getUrlPrefixes: getUrlPrefixes,
    loadJSResourceAsync: loadJSResourceAsync,
    resolveURL: resolveURL,
    toUrl: toUrl,
    unloadResources: unloadResources
  };
  Object.defineProperties(privateAPI, {
    logger: {
      get: function () {
        return log;
      },
      set: function (v) {
        log = v;
      }
    },
    measure: {
      get: function () {
        return measure;
      },
      set: function (v) {
        measure = v;
      }
    },
    assert: {
      get: function () {
        return assert;
      },
      set: function (v) {
        assert = v;
      }
    },
    translate: {
      get: function () {
        return translate;
      },
      set: function (v) {
        translate = v;
      }
    }
  });
  __global.sap = __global.sap || ({});
  sap.ui = sap.ui || ({});
  sap.ui.loader = {
    config: ui5Config,
    _: privateAPI
  };
  amdRequire.config = amdConfig;
  sap.ui.define = ui5Define;
  sap.ui.predefine = predefine;
  sap.ui.require = ui5Require;
  sap.ui.requireSync = requireSync;
})(window);
